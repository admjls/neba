<section>
	<header><h2 id="api_ResourceModel">Writing @ResourceModels</h2></header>

	<h3 id="resourceModelDefinition">Resources, resource types and resource models</h3>

	<section class="info">
		<h4>Background: How NEBA uses resource types in Sling</h4>
		<p>The <a href="http://sling.apache.org/site/index.html">Sling webframework</a> is a REST architecture implementation.
			Consequently, it treats each thing
			it works with (every piece of content, every script, servlet) as a <a href="http://sling.apache.org/site/resources.html">Resource</a>.
			Resources are strongly typed by their attribute <em>sling:resourceType</em>.
			Thus, every component we are writing and every piece of content (i.e. concrete component instance created by an editor by
			placing a component on a site) has a resource type. Resource types - very much like types in many other languages - also support inheritance
			by means of a <em>sling:resourceSuperType</em> attribute.</p>

		<p>Resource types are used by Sling to determine the view(s) that shall be used to render the resource. It does so by adding
			a prefix such as /apps or /libs to the resource type and checking whether it finds views for the
			resource in the corresponding directory.</p>

		<p>Furthermore, any content stored in the JCR is represented by a javax.jcr.Node - this node also has a <em>primaryType</em>
			as well as one or more <em>mixin types</em> and <em>super types</em>.</p>

		<p>In order to provide a JAVA model for a resource, it thus makes sense to either associate
			it with the resource's sling:resourceType or the resource's JCR type. This association is represented using a @ResourceModel
			annotation.</p>
	</section>

	<p>Let's assume we need a simple JAVA model for a sling component called &quot;carousel&quot;.
		The carousel has the sling:resourceType &quot;foundation/components/carousel&quot;. The component has the following properties:</p>

	<p><img src="images/userguide/geometrixx-carousel.png"></p>

	<section class="info">
		<h4>Hint: Leveraging the resource type hierarchy</h4>
		<p>The resource type given in the @ResourceModel annotation must not be the exact
			resource type of the resource; you may also specify  any resource super type of the resource, primary
			node type or mixin type. In our case, the resource super type of the carousel is &quot;foundation/components/list&quot;
			(see the carousel component in /libs/foundation/components/carousel). Try using this resource type in your
			model, and you will notice that it works, too.  This way, you can provide general models for super types,
			and more specific models for derived types, e.g. a generic model for pages and  a more specific model
			for specific page types.</p>
	</section>

	<p>Create the following class in your bundle package (i.e. within or below the &quot;my.bundle.namespace&quot;
		package)</p>

	{% highlight java %}
	@ResourceModel(types = "foundation/components/carousel")
	public class Carousel {
	}
	{% endhighlight %}

	<p>Build it and install the bundle in the OSGi container. Make sure the bundle is active. Now open the <a
			href="http://localhost:4502/system/console/modelregistry">NEBA model registry</a> tab in the sling console.
		Your model should appear in the model list. If not, check the error.log; something might be wrong with your bundle -
		e.g. it might not be detected by gemini-blueprint.</p>

	<section class="info">
		<h4>Background: @ResourceModels</h4>
		<p>Classes annotated with @ResourceModel are <a
				href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-definition">regular
			spring beans</a>. If you look at the @ResourceModel annotation, you will notice that it is itself annotated
			with @Component (a spring stereotype) and @Scope(PROTOTYPE). <a
					href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-classpath-scanning">With
				these annotations, the class is detected by Spring's classpath scanning</a>. It is entirely possible to
			give your model a different scope (such as singleton) if it represents a &quot;static&quot; piece of
			content, such as configuration content stored under /etc/. Furthermore, all capabilities of the spring
			container are available to the model, such as IOC (dependency injection), e.g. using the <a
					href="http://jcp.org/en/jsr/detail?id=330">JSR-330 @Inject</a> annotation, bean lifecycle
			annotations such as @PostConstruct and @PreDestroy, @Scheduled methods and so forth.</p>
	</section>

	<p>To use this model in a JSP, add the neba:defineObjects tag to the carousel script: <a
			href="http://localhost:4502/crx/de/index.jsp#/crx.default/jcr%3aroot/libs/foundation/components/carousel/carousel.jsp">/libs/foundation/components/carousel/carousel.jsp</a>:
	</p>

	<h3 id="nebaDefineObjects">The neba:defineObjects tag</h3>

	{% highlight java %}<%@taglib prefix="neba" uri="http://neba.io/1.0"%>
	<neba:defineObjects />
	{% endhighlight %}

	<p>neba:defineObjects looks up the most specific model for the current resource and publishes it into the JSP context under the key &quot;m&quot;.
		You may now output the model like so:</p>

	{% highlight java %}${m}{% endhighlight %}

	<p>The <em>most specific model</em> is the one who's <em>type</em> attribute points to the closest type within a resource's type
		hierarchy. For example, if the resource has the type "cq:Page" and the super type "nt:base", a  model
		for "cq:Page" is <em>more specific</em> than one for "nt:base". If there are more than one most specific models, e.g. two models
		for "cq:Page", the neba:defineObjectsTag will not provide the model automatically. Then, you can explicity specify the desired model's
		bean name (you can lookup the bean name in the <a href="http://localhost:4502/system/console/modelregistry">model registry</a>):</p>

	{% highlight java %}
	<neba:defineObjects useModelNamed="carousel"/>
	{% endhighlight %}

	<h3 id="resourceToModelMapping">Mapping properties and resources to models</h3>

	<p>To make it more interesting, we can now add some of the resource's properties to the model. You can see the
		properties e.g. in the CRXDE light.</p>

	<p><img src="images/userguide/geometrixx-carousel.png"></p>

	<p>Let's take &quot;pages&quot;, &quot;playSpeed&quot;, &quot;transTime&quot; and add them to the model:</p>

	{% highlight java %}
	@ResourceModel(types = "foundation/components/carousel")
	public class Carousel {
		private String playSpeed;
		private String transTime;
		private List<Resource> pages;

		public String getPlaySpeed() {
			return playSpeed;
		}
		public String getTransTime() {
			return transTime;
		}
		public List<Resource> getPages() {
			return pages;
		}
	}
	{% endhighlight %}

	<p>Now build and deploy your bundle again and output the properties in the JSP like so:</p>

	{% highlight java %}Play speed: ${m.playSpeed}<br />
	Trans time: ${m.transTime}<br />
	Pages: ${m.pages}
	{% endhighlight %}

	<p>You will see the following output:</p>

	{% highlight java %}Play speed: 6000
	Trans time: 1000
	Pages:
	{% endhighlight %}

	<h3 id="resourceAnnotations">Annotations for advanced resource to model mapping</h3>

	<p>All NEBA annotations are also supported as meta-annotations - thus, custom annotations annotated with any of the annotations provided
		by NEBA are treated as if the corresponding NEBA annotation was directly applied.</p>

	<h4 id="api_Reference">Resolving references with the @Reference annotation</h4>

	<p><span id="api_Unmapped">NEBA automatically maps the properties of a Resource to fields named like the properties, unless the field is
		annotated with @Unmapped</span>.  Notice that play speed and trans time are Strings in this example, whereas one would
		expect them to be integers. This is simply because these values are defined to be Strings in the component's
		dialog. Had they been defined as integers, we could also retrieve them as integers. You will also notice that &quot;pages&quot;
		is null. And no wonder - the &quot;pages&quot; property is actually of type &quot;String[]&quot;, so the field
		should also be of type String[] and not List&lt;Resource&gt;. However, NEBA offers a simple way to declare that a
		field contains one ore more <em>references</em> to other Resources. Simply add the @Reference annotation like so:</p>

	{% highlight java %}
	@Reference
	private List<Resource> pages;
	{% endhighlight %}

	<p>Deploy, and load the page again. Now all referenced pages get listed:</p>

	{% highlight java %}Play speed: 6000
	Trans time: 1000
	Pages: [JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/techsummit, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/userconf, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/shapecon, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/dsc]
	{% endhighlight %}

	<p>When NEBA detects a @Reference annotation, it assumes that the <em>value</em> of the corresponding property
		(here: &quot;pages&quot;) is one or more resource paths. It obtains the corresponding resources and provides them as
		a Collection (or a single resource, if the annotated field is not a collection type). However, you are not limited
		to using &quot;Resource&quot; for your reference. The following also works, provided there is a &quot;Page&quot;
		model the referenced resources can be adapted to:</p>

	{% highlight java %}
	@Reference
	private List<Page> pages;
	{% endhighlight %}

	<p>Here, NEBA loads the resource referenced in the &quot;pages&quot; property, adapts each resource to &quot;Page&quot;
		and returns a collection containing the resulting Page instances.</p>

	<p>One can also alter the path of the reference prior to resolution by appending a relative path segment to the reference(s), like so:</p>

	{% highlight java %}
	@Reference(append = "/jcr:content")
	@Path("pages")
	private List<PageContent> pageContents;
	{% endhighlight %}

	<p>Here, instead of resolving and adapting the paths in the property "pages" directly, "/jcr:content" is appended to all of the paths prior to resolution.</p>

	<h4 id="api_Children">Resolving children with the @Children annotation</h4>

	<p>While the resource hierarchy is conveniently navigable using the generic Resource model (i.e. using getChildren()), one often has to
		subsequently adapt the children. Consequently, the children are adapted in a loop, including a null check for each adaptation result.
		Here, NEBA offers another powerful annotation: @Children. This annotation can be used on a Collection, Set or List-typed field
		(similar to the @Reference-annotation). Then, NEBA injects the children of either the current resource (if no other
		annotation is present), or of the resource defined by the @Reference or @Path of the field:</p>

	{% highlight java %}
	@Children
	private List<Resource> children;
	{% endhighlight %}

	<p>Of course, NEBA will also automatically adapt the children to the generic type of the list - for instance, you could write:</p>

	{% highlight java %}
	@Children
	private List<Page> childPages;
	{% endhighlight %}

	<p>@Children can be combined with both @Reference and @Path to even fetch the children of a reference resource
		or a resource designated by a specific path, i.e. the following works as well:</p>

	{% highlight java %}
	@Path("/content/site")
	@Children
	private List<Page> countryPages;

	@Reference
	@Path("link")
	@Children
	private List<Page> linkChildren;

	@Reference
	@Children
	private List<Page> link;
	{% endhighlight %}

	<p>Furthermore, you may specify a relative path to be resolved below every child using the property "resolveBelowEveryChild"
		instead of returning the direct children of the designated resource.
		For example, you could obtain all nodes called "jcr:content" underneath all children of the current resource, like so:</p>

	{% highlight java %}
	@Children(resolveBelowEveryChild = "jcr:content")
	private List<PageContent> childPageContents;
	{% endhighlight %}

	<h4 id="api_Resource">Using the @Path annotation to specify property names or resource paths</h4>

	<p>Now, lets add another property to the model, jcr:lastModified.</p>

	{% highlight java %}private Date lastModified;{% endhighlight %}

	<p>This will not yet work - NEBA mapps the properties by <em>name</em>, in this case the name contains
		characters (&quot;jcr:&quot;) unsuitable for a field name.  In this case, use the @Path annotation to specify
		the property from which the field's value shall be obtained:</p>

	{% highlight java %}
	@Path("jcr:lastModified")
	private Date lastModified;
	{% endhighlight %}

	<p>Now the property is mapped!  @Path has even more interesting features, for instance allowing absolute and
		relative paths.  Try this:</p>

	{% highlight java %}
	@Path("/content/geometrixx/en")
	private Resource en;
	{% endhighlight %}

	<p id="path-placeholders">Furthermore, one can use placeholders in the @Path to dynamically provide path elements.
		A better version of above example is:</p>

	{% highlight java %}
	@Path("/content/geometrixx/${language}")
	private Resource homepage;
	{% endhighlight %}

	<p>To resolve the ${language} placeholder, one simply provides a bean implementing the
		<a href="apidocs/neba-api/io/neba/api/configuration/class-use/PlaceholderVariableResolver.html">PlaceholderVariableResolver interface</a>.
		Such a bean instance will be asked to resolve the value for a placeholder key, i.e. &quot;language&quot;
		in the above example. A completely hardcoded example would be:</p>

	{% highlight java %}
	@Service
	public class MyVariableResolver implements PlaceholderVariableResolver {
		public String resolve(String variableName) {
			if ("language".equals(variableName)) {
			return "en";
			}
			return null;
		}
	}
	{% endhighlight %}

	<h4>The @This annotation</h4>

	<p id="api_This">The same applies to members injected with an absolute @Path and the @This annotation; if you have multiple
		models compatible  to your resource, you may also write:</p>

	{% highlight java %}
	@This
	private OtherModel resource;
	{% endhighlight %}

	<p>You can also use the @This annotation to obtain the Resource that is mapped onto the model:</p>

	{% highlight java %}
	@This
	private Resource resource;
	{% endhighlight %}

	<section class="info">
		<h4>Hint: Models for crosscutting concerns</h4>

		<p>A @ResourceModel is not restricted to sling:resourceType's - you can also map
			it to the JCR primary node type or any of the mixin types of a Node.  For example, let's assume that you
			have a requirement to implement a custom access protection of <em>arbitrary</em> content. In addition, a content manager may configure
			access restriction to <em>any</em> content (e.g. pages or a binary assets). In this case, we know neither the resource
			types nor the content paths to which the protection applies in advance.
			Here, using a mixin node type could help. A mixin can be assigned to any
			node at any time anywhere in the content hierarchy. It can define additional properties that can be set
			on the node, such as a set of properties defining how an access restriction is configured. Let us
			assume a protected content is assigned the mixin &quot;myProject:AccessRestricted&quot;. You may then create
			a model for any access restricted content like so:</p>

		{% highlight java %}
		@ResourceModel(types = "myProject:AccessRestricted")
		public class AccessRestricted {
		....
		}
		{% endhighlight %}

		<p>Finally, you could adapt to this model (e.g., in a view or filter) to determine whether the
			corresponding resource has restricted access, and what the restrictions are.</p>

		<p>Further reading: <a href="http://www.day.com/specs/jcr/2.0/3_Repository_Model.html">JCR repository
			spec</a>, <a href="http://dev.day.com/docs/en/crx/current/using_crx/nodetype_administration.html">administering
			node types</a>.</p>
	</section>

	<h3 id="lazyLoading">Lazy loading</h3>

	<h4>Lazy loading collections of references</h4>

	<p>All collection-typed references are automatically provided as lazy-loading proxies, for example in case of
		<a href="#api_Children">@Children</a> and <a href="#api_Reference">@Reference</a> collections:</p>

	{% highlight java %}
	@ResourceModel(types = "...")
	public class MyModel {
		@Children
		private List<Page> children; // Provided as a lazy-loading proxy
		@Reference
		private Collection<Page> pages; // Provided as a lazy-loading proxy as well
	}
	{% endhighlight %}

	<p>The contents of these collection are loaded as soon as a collection method - such as get, size, isEmpty, iterator - is called.
		The lazy-loading behavior for collections is thus completely transparent.</p>

	<h4 id="api_Optional">Declaring lazy-loading relationships using the Optional&lt;T&gt; interface</h4>

	<p>1:1 relationships are not automatically lazy. In order to make them lazy-loading,
		NEBA provides the <a href="apidocs/neba-api/io/neba/api/resourcemodels/Optional.html">Optional</a> interface:</p>

	{% highlight java %}
	@ResourceModel(types = "...")
	public class MyModel {
		@Reference
		private Optional<Page> page;
		@Path("/content/path")
		private Optional<Resource> otherResource;
	}
	{% endhighlight %}

	<section class="info">
		<h4>Background: Why 1:1 relationships are not lazy by default</h4>

		<p>Let us assume there is a resource model that references resource "r":</p>

		{% highlight java %}
		@ResourceModel(types = "...")
		public class MyModel {
			@Reference
			private Resource r;

			public void doSomething() {
				if (r != null) {
					// work with r
				}
			}
		}
		{% endhighlight %}

		<p>Of course, any client working with "r" must know whether r exists. However, there is no natural "empty" representation for r.
			It is either null or it exists. However, if r was provided as a lazy-loading proxy it could never be null - since determining whether r exists (is not null)
			would mean loading it, which directly contradicts the idea of lazy-loading.</p>

		<p>A user of "r" would only find out that "r" does not exist when accessing a method of the "r" lazy-loading proxy (which is never null)  - and receiving an
			unfriendly unchecked exception in return, since the proxy cannot dispatch the method call as the loaded "r" is null.</p>

		<p>Consequently, lazy 1:1 relationships <em>must</em> be explicit to allow clients to determine whether the relationship exists. This is not the case for
			collection-typed references, since collections have a natural "empty" state (isEmpty()) and are guaranteed not to be null by NEBA.</p>
	</section>

	<p>The Optional&lt;T&gt; interface is an extract of the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">JAVA 8 "Optional" interface</a>. NEBA
		automatically provides an implementation that will load the reference upon request. Of course, you may also use the interface for collection-typed references:</p>

	{% highlight java %}
	@ResourceModel(types = "...")
	public class MyModel {
		@Children
		private Optional<Collection<Page>> children;
		@Reference
		private Optional<Collection<Page>> pages;
	}
	{% endhighlight %}

	<p>In this case, NEBA will not provide the collection as a lazy-loading proxy, but simply load it when requested via
		the Optional interface implementation.</p>

	<h3 id="api_PreMapping-and-PostMapping">Performing additional initializations</h3>

	<p>It is often required to perform some additional initializations
		after all properties of a @ResourceModel are mapped. NEBA supports this use case with the @PostMapping and
		@PreMapping annotations.  Similar to @PostConstruct and @PreDestroy from standard Java, these annotations mark methods to be
		invoked after all properties of a resource model are mapped from its resource:</p>


	{% highlight java %}@ResourceModel(types = "my/model/type")
	public class MyModel {
		@This
		private Resource resource;
		@PostMapping
		public void initializeSomething() {
			// resource is initialized at this point.
			this.resource.adaptTo...
		}
	}
	{% endhighlight %}

	<p>Likewise, @PreMapping allows for method execution before any properties of the resource are mapped.</p>
</section>