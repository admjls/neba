<section><header><h2 id="writing_resourcemodels">Writing @ResourceModels</h2></header>

<h3 id="about_resource_models">Resources, resource types and resource models</h3>

<section class="info">
    <h4>Background: How NEBA uses resource types in Sling</h4>
    <p>The <a href="http://sling.apache.org/site/index.html">Sling webframework</a> is a REST architecture implementation.
        Consequently, it treats each thing it works with (every piece of content, every script, servlet) as a <a href="http://sling.apache.org/site/resources.html">Resource</a>.
        Resources are typed using the property <em>sling:resourceType</em>. Resource types - very much like types in many other languages - also support inheritance
        by means of a <em>sling:resourceSuperType</em> attribute.</p>

    <p>Resource types are used by Sling to determine the view(s) that shall be used to render the resource. It does so by adding
        a prefix such as /apps or /libs to the resource type and checking whether it finds views for the
        resource in the corresponding directory.</p>

    <p>Furthermore, any content stored in the JCR is represented by a javax.jcr.Node. Nodes are strongly typed - they always possess a <em>primaryType</em>
        as well as an arbitrary number of<em>mixin types</em>. Both the primary type and the mixin types can have <em>super types</em>.</p>

    <p>In order to provide a JAVA model for a resource, it thus makes sense to either associate
        it with the resource's sling:resourceType or the resource's Node type. This association is represented using a @ResourceModel
        annotation.</p>
</section>

<p>Let's assume we need a simple JAVA model for a sling component called &quot;carousel&quot;.
    The carousel has the sling:resourceType &quot;foundation/components/carousel&quot;. The component has the following properties:</p>

<div class="listing" id="listing:sample-content">{%  highlight json %}
{
  "jcr:primaryType": "nt:unstructured",
  "playSpeed": "6000",
  "jcr:lastModifiedBy": "admin",
  "pages": [
    "/content/geometrixx/en/events/techsummit",
    "/content/geometrixx/en/events/userconf"
  ],
  "jcr:lastModified": "Tue Oct 05 2010 14:14:27 GMT+0200",
  "transTime": "1000",
  "sling:resourceType": "foundation/components/carousel",
  "listFrom": "static"
  }
{% endhighlight %}<div class="legend">A typical JSON view of JCR repository content</div></div>

<p>Create the following class in your bundle package (i.e. within or below the &quot;my.bundle.namespace&quot;
    package)</p>

<div class="listing" id="listing:resource-model-annotation">{% highlight java %}
@ResourceModel(types = "foundation/components/carousel")
public class Carousel {
}
{% endhighlight %}<div class="legend">Application of the @ResourceModel annotation on a Bean</div></div>

<p>The resource type given in the @ResourceModel annotation does not have to be the exact
    resource type of the resource. One may also specify any resource super type of the resource, primary
    node type or mixin type. for example, the resource super type of the carousel could be &quot;foundation/components/list&quot;.
    Using this resource type in a @ResourceModel would work, too. This way, one can provide general models for super types,
    and more specific models for derived types, e.g. a generic model for pages and  a more specific model
    for specific page types.</p>

<section class="info">
    <h4>Background: The @ResourceModel annotation</h4>
    <p>Classes annotated with @ResourceModel are <a
            href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-definition">regular
        spring beans</a>: The @ResourceModel annotation itself is annotated
        with @Component (a spring stereotype) and @Scope(PROTOTYPE). <a
                href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-classpath-scanning">With
            these annotations, the class is detected by Spring's classpath scanning</a>. It is entirely possible to
        give a model a different scope (such as singleton) if it represents a &quot;static&quot; piece of
        content, such as configuration content stored under /etc/. Furthermore, all capabilities of the spring
        container are available to a model, such as IOC (dependency injection), e.g. using the <a
                href="http://jcp.org/en/jsr/detail?id=330">JSR-330 @Inject</a> annotation, bean lifecycle
        annotations such as @PostConstruct and @PreDestroy, @Scheduled methods and so forth.</p>
</section>

<p>Once a bundle with NEBA models and a blueprint context is active, all of its models must appear in the <a
        href="#tooling_modelregistry">NEBA model registry (/system/console/modelregistry)</a> in the sling console.
    If not, the blueprint context likely failed to start. In such cases analyzing the error.log is advisable.</p>

<h3 id="using_models_in_views">Using models in views</h3>

<p>Resource models can be automatically provided in either HTL (Sightly) or JSP views using the neba.js or neba:defineObjects tag library, respectively:</p>

<div class="listing" id="listing:neba-js-in-htl">{% highlight html %}
<sly data-sly-use.m="/apps/neba/neba.js"> ... </sly>
{% endhighlight %}<div class="legend">Using the neba.js to obtain the most specific NEBA model in an HTL (Sightly) view</div></div>

<div class="listing" id="listing:neba-defineobjects-jsp-tag">{% highlight html %}
<%@taglib prefix="neba" uri="http://neba.io/1.0"%>
<neba:defineObjects />
{% endhighlight %}<div class="legend">Importing the NEBA taglib namespace</div></div>

<p>Both are looking up the most specific model for the current resource.
    The neba:defineObjects tag always publishes the model into the scripting context under the key &quot;m&quot;.
    In both examples above, you could access the model like so:</p>

<div class="listing" id="listing:accessing-the-neba-model">{% highlight java %}${m}{% endhighlight %}<div class="legend">Acessing the NEBA model in HTL (Sightly) or JSP</div></div>

<p>
    The <em>most specific model</em> is the one who's <em>type</em> attribute points to the closest type within a resource's type
    hierarchy. For example, if the resource has the type "cq:Page" and the super type "nt:base", a  model
    for "cq:Page" is <em>more specific</em> than one for "nt:base". If there is more than one most specific model, e.g. two models
    for "cq:Page", neba.js and the neba:defineObjectsTag will not provide the model automatically. In such cases, you could either
    explicitly adapt to the desired model type or specify the desired model's
    bean name (you can lookup the bean name in the <a href="#tooling_modelregistry">model registry</a>), like so:
</p>

<div class="listing" id="listing:neba-model-by-name-in-htl">{% highlight html %}
<sly data-sly-use.m="${'/apps/neba/neba.js' @ beanName=carousel}"> ... </sly>
{% endhighlight %}<div class="legend">Resolving a NEBA model by name in HTL (Sightly)</div></div>

<div class="listing" id="listing:neba-model-ny-name-ion-jsp">{% highlight html %}
<neba:defineObjects useModelNamed="carousel"/>
{% endhighlight %}<div class="legend">Resolving a NEBA model by name in JSP</div></div>

<p>However, one may also explicitly adapt the current resource to the model, like so:</p>

<div class="listing" id="listing:adapt-to-neba-model-in-htl">{% highlight html %}
<sly data-sly-use.m="my.package.MyModel"> ...</sly>
{% endhighlight %}<div class="legend">Directly adapting to a NEBA model in HTL (Sightly)</div></div>

<div class="listing" id="listing:adapt-to-neba-model-in-jsp">{% highlight java %}
<% MyModel model = resource.adaptTo(my.package.MyModel.class); %>
{% endhighlight %}<div class="legend">Directly adapting to a NEBA model in JSP</div></div>

<h3 id="mapping_resources_to_models">Mapping properties and resources to models</h3>

<p>
    Following, we will map the properties of the carousel sample content, as defined in the previous chapter:
<div class="listing" id="listing:sample-content-repeat">{%  highlight json %}
{
  "jcr:primaryType": "nt:unstructured",
  "playSpeed": "6000",
  "jcr:lastModifiedBy": "admin",
  "pages": [
    "/content/geometrixx/en/events/techsummit",
    "/content/geometrixx/en/events/userconf"
  ],
  "jcr:lastModified": "Tue Oct 05 2010 14:14:27 GMT+0200",
  "transTime": "1000",
  "sling:resourceType": "foundation/components/carousel",
  "listFrom": "static"
  }
{% endhighlight %}<div class="legend">A typical JSON view of JCR repository content</div></div>

<p>Let's take &quot;pages&quot;, &quot;playSpeed&quot;, &quot;transTime&quot; and add them to the model:</p>

<div class="listing" id="listing:neba-resourcemodel-with-simple-fields">{% highlight java %}
@ResourceModel(types = "foundation/components/carousel")
public class Carousel {
    private String playSpeed;
    private String transTime;
    private List<String> pages;

    public String getPlaySpeed() {
        return playSpeed;
    }
    public String getTransTime() {
        return transTime;
    }
    public List<Resource> getPages() {
        return pages;
    }
}
{% endhighlight %}<div class="legend">A simple @ResourceModel with mapped fields</div></div>

<p>Now build and deploy your bundle again and output the properties in the view like so:

<div class="listing">
{% highlight java %}Play speed: ${m.playSpeed}<br />
Trans time: ${m.transTime}<br />
Pages: ${m.pages}
{% endhighlight %}
</div>

<p>You will see the following output:</p>

<div class="listing">
{% highlight java %}Play speed: 6000
Trans time: 1000
Pages: ["/content/geometrixx/en/events/techsummit", ...]
{% endhighlight %}
</div>

<h3 id="resource_model_annotations">Annotations for resource to model mapping</h3>

<p>All NEBA annotations can also supported as meta-annotations - thus, custom annotations annotated with any of the annotations provided
by NEBA are treated as if the corresponding NEBA annotation was directly applied.</p>

<h4 id="the_reference_annotation">Resolving references with the @Reference annotation</h4>

<p><span id="the_unmapped_annotation">NEBA automatically maps the properties of a Resource to fields named like the properties, unless the field is
    annotated with @Unmapped</span>.  Notice that play speed and trans time are Strings in <a href="#listing:sample-content-repeat">the above example</a>, whereas one would
    expect them to be integers. This is simply because these values are defined to be Strings in the component's CQ
    dialog. Had they been defined as integers, we could also retrieve them as integers. You will also notice that &quot;pages&quot;
    is null. And no wonder - the &quot;pages&quot; property is actually of type &quot;String[]&quot;, so the field
    should also be of type String[] and not List&lt;Resource&gt;. However, NEBA offers a simple way to declare that a
    field contains one ore more <em>references</em> to other Resources. Simply add the @Reference annotation like so:</p>

<div class="listing" id="listing:neba-reference-annotation">{% highlight java %}
@Reference
private List<Resource> pages;
{% endhighlight %}<div class="legend">Using the @Reference annotation</div></div>

<p>Deploy, and load the page again. Now all referenced pages get listed:</p>

<div class="listing">
{% highlight java %}Play speed: 6000
Trans time: 1000
Pages: [JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/techsummit, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/userconf]
{% endhighlight %}
</div>

<p>When NEBA detects a @Reference annotation, it assumes that the <em>value</em> of the corresponding property
    (here: &quot;pages&quot;) is one or more resource paths. It obtains the corresponding resources and provides them as
    a Collection (or a single resource, if the annotated field is not a collection type). However, you are not limited
    to using &quot;Resource&quot; for your reference. The following also works, provided there is a &quot;Page&quot;
    model the referenced resources can be adapted to:</p>

<div class="listing" id="listing:neba-reference-annotation-with-adaptto">
{% highlight java %}
@Reference
private List<Page> pages;
{% endhighlight %}<div class="legend">Using the @Reference annotation with resource adaptation</div></div>

<p>Here, NEBA loads the resource referenced in the &quot;pages&quot; property, adapts each resource to &quot;Page&quot;
    and returns a collection containing the resulting Page instances.</p>

One can also alter the path of the reference prior to resolution by appending a relative path segment to the reference(s), like so:

<div class="listing" if="listing:neba-reference-annotation-with-append">
{% highlight java %}
@Reference(append = "/jcr:content")
@Path("pages")
private List<PageContent> pageContents;
{% endhighlight %}
<div class="legend">Appending paths to the resources resolved via the @Reference annotation</div></div>

<p>
Here, instead of resolving and adapting the paths in the property "pages" directly, "/jcr:content" is appended to all of the paths prior to resolution.
</p>

<h4 id="the_children_annotation">Resolving children with the @Children annotation</h4>

<p>While the resource hierarchy is conveniently
    navigable using the generic Resource model (i.e. using getChildren()), one often has to subsequently adapt the children. Consequently,
    the children are adapted in a loop, including a null check for each adaptation result. Here, NEBA offers
    another powerful annotation: @Children. This annotation can be used on a Collection, Set or List-typed field
    (similar to the @Reference-annotation). Then, NEBA injects the children of either the current resource (if no other
    annotation is present), or of the resource defined by the @Reference or @Path of the field:</p>

<div class="listing" id="listing:neba-children-annotation">
{% highlight java %}
@Children
private List<Resource> children;
{% endhighlight %}
<div class="legend">Using the @Children annotation</div></div>

<p>Of course, NEBA will also automatically adapt the children to the generic type of the list - for instance,
    you could write:</p>

<div class="listing" id="listing:neba-children-annotation-with-adaptation">
{% highlight java %}
@Children
private List<Page> childPages;
{% endhighlight %}
<div class="legend">Using the @Children annotation with adaptation</div></div>

<p>@Children can be combined with both @Reference and @Path to even fetch the children of a reference resource
    or a resource designated by a specific path, i.e. the following works as well:</p>

<div class="listing" id="listing:combination-of-children-reference-path">
{% highlight java %}
@Path("/content/site")
@Children
private List<Page> countryPages;

@Reference
@Path("link")
@Children
private List<Page> linkChildren;

@Reference
@Children
private List<Page> link;
{% endhighlight %}
<div class="legend">Combining @Children, @Reference and @Path</div></div>

<p>
    Furthermore, you may specify a relative path to be resolved below every child using the property "resolveBelowEveryChild"
    instead of returning the direct children of the designated resource.
    For example, you could obtain all nodes called "jcr:content" underneath all children of the current resource, like so:
</p>

<div class="listing" id="listing:neba-children-annotation-with-resolvebeloweverychild">{% highlight java %}
@Children(resolveBelowEveryChild = "jcr:content")
private List<PageContent> childPageContents;
{% endhighlight %}
<div class="legend">Altering the paths of the resources resolved by @Children</div></div>

<h4 id="the_path_annotation">Using the @Path annotation to specify property names or resource paths</h4>

<p>Now, lets add another property to the model, jcr:lastModified.</p>

<div class="listing">
{% highlight java %}
private Date lastModified;
{% endhighlight %}
</div>

<p>This will not yet work - NEBA mapps the properties by <em>name</em>, in this case the name contains
    characters (&quot;jcr:&quot;) unsuitable for a field name.  In this case, use the @Path annotation to specify
    the property from which the field's value shall be obtained:</p>

<div class="listing" id="listing:neba-path-annotation">{% highlight java %}
@Path("jcr:lastModified")
private Date lastModified;
{% endhighlight %}<div class="legend">Using the @Path annotation</div></div>

<p>Now the property is mapped!  @Path has even more interesting features, for instance allowing absolute and
    relative paths.  Try this:</p>

<div class="listing" id="listing:neba-path-annotation-with-absolute-paths">{% highlight java %}
@Path("/content/geometrixx/en")
private Resource en;
{% endhighlight %}<div class="legend">Using the @Path annotation with absolute paths</div></div>

<p id="path_placeholders">Furthermore, one can use placeholders in the @Path to dynamically provide path elements.
    A better version of above example is:</p>

<div class="listing" id="listing:path-annotation-with-placeholders">
{% highlight java %}
@Path("/content/geometrixx/${language}")
private Resource homepage;
{% endhighlight %}
<div class="legend">Using placeholders in the @Path annotation</div></div>

<p>To resolve the ${language} placeholder, one simply provides a bean implementing the
    <a href="/apidocs/neba-api/io/neba/api/configuration/PlaceholderVariableResolver.html">PlaceholderVariableResolver interface</a>.
    Such a bean instance will be asked to resolve the value for a placeholder key, i.e. &quot;language&quot;
    in the above example. A completely hardcoded example would be:</p>

<div class="listing" id="listing:neba-placeholder-variable-resolver">
{% highlight java %}
@Service
public class MyVariableResolver implements PlaceholderVariableResolver {
    public String resolve(String variableName) {
        if ("language".equals(variableName)) {
            return "en";
        }
        return null;
    }
}
{% endhighlight %}<div class="legend">A dummy PlaceholderVariableResolver implementation</div></div>

<h4 id="the_this_annotation">The @This annotation</h4>

<p>Fields annotated with @This are injected with the current resource, or anything the resource is adaptable to. This annotation is thus not just useful for
access to the plain Resource, but has significant architectural value. Using @This, one may split up a model into multiple aspects and compose them dynamically, like so:</p>

<div class="listing" id="listing:neba-this-annotation">{% highlight java %}
@ResourceModel(types = ...)
public class MyModel {
    @This
    // OtherModel models a different aspect of the same resource.
    private OtherModel resource;
}
{% endhighlight %}<div class="legend">Using the @This annotation</div></div>

<p>You can also use the @This annotation to obtain the Resource that is mapped onto the model:</p>

<div class="listing" id="listing:neba-this-annotation-for-resource">
{% highlight java %}
@This
private Resource resource;
{% endhighlight %}<div class="legend">Using the @This annotation to retrieve the resource that is mapped to the model</div></div>

<h3>Models for crosscutting concerns</h3>
<p>A @ResourceModel is not restricted to sling:resourceType's - you can also map
    it to the JCR primary node type or any of the mixin types of a Node.  For example, let's assume that you
    have a requirement to implement a custom access protection of <em>arbitrary</em> content. In addition, a content manager may <em>configure</em>
    access restriction to <em>any</em> content (e.g. pages or a binary assets). In this case, we know neither the resource
    types nor the content paths to which the protection applies in advance.
    Here, using a mixin node type could help. A mixin can be assigned to any
    node at any time anywhere in the content hierarchy. It can define additional properties that can be set
    on the node, such as a set of properties defining how an access restriction is configured. Let us
    assume a protected content is assigned the mixin &quot;mix:AccessRestricted&quot;. You may then create
    a model for any access restricted content like so:</p>

<div class="listing" id="listing:resourcemodel-for-mixin-type">{% highlight java %}
@ResourceModel(types = "mix:AccessRestricted")
public class AccessRestricted {
 ....
}
{% endhighlight %}<div class="legend">Defining a @ResourceModel for a mixin type</div></div>

<p>Finally, you could adapt to this model (e.g., in a view or filter) to determine whether the
    corresponding resource has restricted access, and what the restrictions are.</p>

<p>Further reading: <a href="http://www.day.com/specs/jcr/2.0/3_Repository_Model.html">JCR repository
    spec</a>, <a href="http://dev.day.com/docs/en/crx/current/using_crx/nodetype_administration.html">administering
    node types</a>.</p>

<h3 id="lazy_loading">Lazy loading</h3>

<p>
    Reading data into an object graph - such as NEBA models referencing each other - bears the risk of loading
    more data than required for rendering. Especially when there is a significant amount of repository content, being able to load
    models <em>on demand</em> rather then up front is <em>crucial</em> for building high-performance implementations. To achieve this,
    NEBA enables lazy-loading model relationships.
</p>

<h4>Lazy loading collections of references</h4>

<p>
All collection-typed references are automatically provided as lazy-loading proxies, for example in case of
<a href="#the_children_annotation">@Children</a> and <a href="#the_reference_annotation">@Reference</a> collections:
</p>

<div class="listing" id="listing:neba-implicit-lazy-loading">{% highlight java %}
@ResourceModel(types = "...")
public class MyModel {
  @Children
  private List<Page> children; // Provided as a lazy-loading proxy
  @Reference
  private Collection<Page> pages; // Provided as a lazy-loading proxy as well
}
{% endhighlight %}<div class="legend">Automatic lazy-loading of collection-type instance in NEBA</div></div>

<p>
The contents of these collection are loaded as soon as a collection method - such as get, size, isEmpty, iterator - is called.
The lazy-loading behavior for collections is thus completely transparent.
</p>

<h4 id="the_optional_interface">Declaring lazy-loading relationships using the Lazy&lt;T&gt; interface</h4>

<p>
1:1 relationships are not automatically lazy. In order to make them lazy-loading,
NEBA provides the <a href="apidocs/neba-api/io/neba/api/resourcemodels/Lazy.html">Lazy</a> interface:
</p>

<div class="listing" id="listing:explicit-lazy-loading-with-optional">{% highlight java %}
@ResourceModel(types = "...")
public class MyModel {
  @Reference
  private Lazy<Page> page;
  @Path("/content/path")
  private Lazy<Resource> otherResource;
}
{% endhighlight %}<div class="legend">Explicit lazy-loading using the Lazy interface</div></div>

With Lazy, the relationships is loaded when one of Lazy's methods for model retrieval is invoked, such as "orElse".

<section class="info">
    <h4>Background: Why 1:1 relationships cannot be lazy by default</h4>
    <p>
        Let us assume there is a resource model that references resource "r":
    </p>

    <div class="listing">
    {% highlight java %}
    @ResourceModel(types = "...")
    public class MyModel {
      @Reference
      private Resource r;

      public void doSomething() {
          if (r != null) {
             // work with r
          }
      }
    }
    {% endhighlight %}
    </div>

    <p>
       Of course, any client working with "r" must know it exists. However, there is no natural "empty" representation for Resource -
       it is either null or not. Now, if r was provided as a lazy-loading proxy that proxy instance would never be null (since determining whether the resource represented by "r" exists
       would mean having to load it, which defeats the purpose of lazy-loading).
    </p>
    <p>
        A user of "r" would only find out that "r" does not exist when accessing a method of the "r" lazy-loading proxy - and receiving an
        unchecked exception in return, since the proxy cannot dispatch the method call as the loaded "r" is null.
    </p>
    <p>
        Consequently, lazy 1:1 relationships <em>must</em> be explicit to allow clients to determine whether the relationship exists.
        Collections, on the other hand, do have a natural representation of emptiness (isEmpty) and are thus automatically provided as lazy-loading proxies by NEBA.
    </p>
</section>

<p>
The Lazy&lt;T&gt; interface provides all features of the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">JAVA 8 "Optional" type</a>. NEBA
automatically provides an implementation that will load the reference upon request. Of course, you may also use the interface for collection-typed references:
</p>

<div class="listing" id="listing:explicit-lazy-loading-collections">{% highlight java %}
@ResourceModel(types = "...")
public class MyModel {
  @Children
  private Lazy<Collection<Page>> children;
  @Reference
  private Lazy<Collection<Page>> pages;
}
{% endhighlight %}<div class="legend">Explicit lazy loading of collection instances</div></div>

<p>
    In this case, NEBA will not provide the collection as a lazy-loading proxy, but simply load it when requested via
    the Lazy interface implementation.
</p>

<h3 id="the_premapping_and_postmapping_annotations">Performing additional initializations</h3>

<p>It is often required to perform some additional initializations
    after all properties of a @ResourceModel are mapped. NEBA supports this use case with the @PostMapping and
    @PreMapping annotations.  Similar to @PostConstruct and @PreDestroy from standard Java, these annotations mark methods to be
    invoked after all properties of a resource model are mapped from its resource:</p>


<div class="listing" id="listing:postmapping">{% highlight java %}@ResourceModel(types = "my/model/type")
public class MyModel {
   @This
   private Resource resource;
   @PostMapping
   public void initializeSomething() {
        // resource is initialized at this point.
        this.resource.adaptTo...
   }
}
{% endhighlight %}<div class="legend">Using the @PostMapping annotation</div></div>

<p>Likewise, @PreMapping allows for method execution before any properties of the resource are mapped.</p>

</section>