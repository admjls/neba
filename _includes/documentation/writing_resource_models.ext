<section><header><h2 id="writing_resourcemodels">Writing @ResourceModels</h2></header>

<h3 id="about_resource_models">Resources, resource types and resource models</h3>

<section class="info">
    <h4>Background: How NEBA uses resource types in Sling</h4>
    <p>The <a href="http://sling.apache.org/site/index.html">Sling webframework</a> is a REST architecture implementation.
        Consequently, it treats each thing it works with (every piece of content, every script, servlet) as a <a href="http://sling.apache.org/site/resources.html">Resource</a>.
        Resources are typed using the property <em>sling:resourceType</em>. Resource types - very much like types in many other languages - also support inheritance
        by means of a <em>sling:resourceSuperType</em> attribute.</p>

    <p>Resource types are used by Sling to determine the view(s) that shall be used to render the resource. It does so by adding
        a prefix such as /apps or /libs to the resource type and checking whether it finds views for the
        resource in the corresponding directory.</p>

    <p>Furthermore, any content stored in the JCR is represented by a javax.jcr.Node. Nodes are strongly typed - they aways possess a <em>primaryType</em>
        as well as an arbitrary number of<em>mixin types</em>. Both the primary type and the mixin types can have <em>super types</em>.</p>

    <p>In order to provide a JAVA model for a resource, it thus makes sense to either associate
        it with the resource's sling:resourceType or the resource's Node type. This association is represented using a @ResourceModel
        annotation.</p>
</section>

<p>Let's assume we need a simple JAVA model for a sling component called &quot;carousel&quot;.
    The carousel has the sling:resourceType &quot;foundation/components/carousel&quot;. The component has the following properties:</p>

{%  highlight json %}
{
  "jcr:primaryType": "nt:unstructured",
  "playSpeed": "6000",
  "jcr:lastModifiedBy": "admin",
  "pages": [
    "/content/geometrixx/en/events/techsummit",
    "/content/geometrixx/en/events/userconf",
    "/content/geometrixx/en/events/shapecon",
    "/content/geometrixx/en/events/dsc"
  ],
  "jcr:lastModified": "Tue Oct 05 2010 14:14:27 GMT+0200",
  "transTime": "1000",
  "sling:resourceType": "foundation/components/carousel",
  "listFrom": "static"
  }
{% endhighlight %}

<p>Create the following class in your bundle package (i.e. within or below the &quot;my.bundle.namespace&quot;
    package)</p>

{% highlight java %}
@ResourceModel(types = "foundation/components/carousel")
public class Carousel {
}
{% endhighlight %}

<p>The resource type given in the @ResourceModel annotation does not have to be the exact
    resource type of the resource. One may also specify any resource super type of the resource, primary
    node type or mixin type. for example, the resource super type of the carousel could be &quot;foundation/components/list&quot;.
    Using this resource type in a @ResourceModel would work, too. This way, one can provide general models for super types,
    and more specific models for derived types, e.g. a generic model for pages and  a more specific model
    for specific page types.</p>

<section class="info">
    <h4>Background: The @ResourceModel annotation</h4>
    <p>Classes annotated with @ResourceModel are <a
            href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-definition">regular
        spring beans</a>: The @ResourceModel annotation itself is annotated
        with @Component (a spring stereotype) and @Scope(PROTOTYPE). <a
                href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-classpath-scanning">With
            these annotations, the class is detected by Spring's classpath scanning</a>. It is entirely possible to
        give a model a different scope (such as singleton) if it represents a &quot;static&quot; piece of
        content, such as configuration content stored under /etc/. Furthermore, all capabilities of the spring
        container are available to a model, such as IOC (dependency injection), e.g. using the <a
                href="http://jcp.org/en/jsr/detail?id=330">JSR-330 @Inject</a> annotation, bean lifecycle
        annotations such as @PostConstruct and @PreDestroy, @Scheduled methods and so forth.</p>
</section>

<p>Once a bundle with NEBA models and a blueprint context is active, all of its models must appear in the <a
        href="http://localhost:4502/system/console/modelregistry">NEBA model registry (/system/console/modelregistry)</a> in the sling console.
    If not, the blueprint context likely failed to start. In such cases analyzing the error.log is advisable.</p>

<h3 id="using_models_in_views">Using models in views</h3>

<p>Resource models can be automatically provided in either Sightly or JSP views using the neba.js or neba:defineObjects tag library, respectively:</p>

{% highlight html %}
<sly data-sly-use.m="/apps/neba/neba.js"> ... </sly>
{% endhighlight %}

{% highlight html %}
<%@taglib prefix="neba" uri="http://neba.io/1.0"%>
<neba:defineObjects />
{% endhighlight %}

<p>Both are looking up the most specific model for the current resource.
    The neba:defineObjects tag always publishes the model into the scripting context under the key &quot;m&quot;.
    In both examples above, you could access the model like so:</p>

{% highlight java %}${m}{% endhighlight %}

<p>
    The <em>most specific model</em> is the one who's <em>type</em> attribute points to the closest type within a resource's type
    hierarchy. For example, if the resource has the type "cq:Page" and the super type "nt:base", a  model
    for "cq:Page" is <em>more specific</em> than one for "nt:base". If there is more than one most specific model, e.g. two models
    for "cq:Page", neba.js and the neba:defineObjectsTag will not provide the model automatically. In such cases, you could either
    explicitly adapt to the desired model type or specify the desired model's
    bean name (you can lookup the bean name in the <a href="http://localhost:4502/system/console/modelregistry">model registry</a>), like so:
</p>

{% highlight html %}
<sly data-sly-use.m="${'/apps/neba/neba.js' @ beanName=carousel}"> ... </sly>
{% endhighlight %}

{% highlight html %}
<neba:defineObjects useModelNamed="carousel"/>
{% endhighlight %}

<p>However, one may also explicitly adapt the current resource to the model, like so:</p>

{% highlight html %}
<sly data-sly-use.m="my.package.MyModel"> ...</sly>
{% endhighlight %}

{% highlight java %}
<% MyModel model = resource.adaptTo(my.package.MyModel.class); %>
{% endhighlight %}

<h3 id="mapping_resources_to_models">Mapping properties and resources to models</h3>

<p>
    Following, we will map the properties of the carousel sample content, as defined in the previous chapter:
{%  highlight json %}
{
  "jcr:primaryType": "nt:unstructured",
  "playSpeed": "6000",
  "jcr:lastModifiedBy": "admin",
  "pages": [
    "/content/geometrixx/en/events/techsummit",
    "/content/geometrixx/en/events/userconf",
    "/content/geometrixx/en/events/shapecon",
    "/content/geometrixx/en/events/dsc"
  ],
  "jcr:lastModified": "Tue Oct 05 2010 14:14:27 GMT+0200",
  "transTime": "1000",
  "sling:resourceType": "foundation/components/carousel",
  "listFrom": "static"
  }
{% endhighlight %}

<p>Let's take &quot;pages&quot;, &quot;playSpeed&quot;, &quot;transTime&quot; and add them to the model:</p>

{% highlight java %}
@ResourceModel(types = "foundation/components/carousel")
public class Carousel {
    private String playSpeed;
    private String transTime;
    private List<Resource> pages;

    public String getPlaySpeed() {
        return playSpeed;
    }
    public String getTransTime() {
        return transTime;
    }
    public List<Resource> getPages() {
        return pages;
    }
}
{% endhighlight %}

<p>Now build and deploy your bundle again and output the properties in the view like so:

{% highlight java %}Play speed: ${m.playSpeed}<br />
Trans time: ${m.transTime}<br />
Pages: ${m.pages}
{% endhighlight %}

<p>You will see the following output:</p>

{% highlight java %}Play speed: 6000
Trans time: 1000
Pages:
{% endhighlight %}

<h3 id="resource_model_annotations">Annotations for resource to model mapping</h3>

<p>All NEBA annotations can also supported as meta-annotations - thus, custom annotations annotated with any of the annotations provided
by NEBA are treated as if the corresponding NEBA annotation was directly applied.</p>

<h4 id="the_reference_annotation">Resolving references with the @Reference annotation</h4>

<p><span id="the_unmapped_annotation">NEBA automatically maps the properties of a Resource to fields named like the properties, unless the field is
    annotated with @Unmapped</span>.  Notice that play speed and trans time are Strings in this example, whereas one would
    expect them to be integers. This is simply because these values are defined to be Strings in the component's CQ
    dialog. Had they been defined as integers, we could also retrieve them as integers. You will also notice that &quot;pages&quot;
    is null. And no wonder - the &quot;pages&quot; property is actually of type &quot;String[]&quot;, so the field
    should also be of type String[] and not List&lt;Resource&gt;. However, NEBA offers a simple way to declare that a
    field contains one ore more <em>references</em> to other Resources. Simply add the @Reference annotation like so:</p>

{% highlight java %}
@Reference
private List<Resource> pages;
{% endhighlight %}

<p>Deploy, and load the page again. Now all referenced pages get listed:</p>

{% highlight java %}Play speed: 6000
Trans time: 1000
Pages: [JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/techsummit, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/userconf, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/shapecon, JcrNodeResource, type=cq:Page, superType=null, path=/content/geometrixx/en/events/dsc]
{% endhighlight %}

<p>When NEBA detects a @Reference annotation, it assumes that the <em>value</em> of the corresponding property
    (here: &quot;pages&quot;) is one or more resource paths. It obtains the corresponding resources and provides them as
    a Collection (or a single resource, if the annotated field is not a collection type). However, you are not limited
    to using &quot;Resource&quot; for your reference. The following also works, provided there is a &quot;Page&quot;
    model the referenced resources can be adapted to:</p>

{% highlight java %}@Reference
private List<Page> pages;
{% endhighlight %}

<p>Here, NEBA loads the resource referenced in the &quot;pages&quot; property, adapts each resource to &quot;Page&quot;
    and returns a collection containing the resulting Page instances.</p>

One can also alter the path of the reference prior to resolution by appending a relative path segment to the reference(s), like so:

{% highlight java %}@Reference(append = "/jcr:content")
@Path("pages")
private List<PageContent> pageContents;
{% endhighlight %}

<p>
Here, instead of resolving and adapting the paths in the property "pages" directly, "/jcr:content" is appended to all of the paths prior to resolution.
</p>

<h4 id="the_children_annotation">Resolving children with the @Children annotation</h4>

<p>While the resource hierarchy is conveniently
    navigable using the generic Resource model (i.e. using getChildren()), one often has to subsequently adapt the children. Consequently,
    the children are adapted in a loop, including null check for each adaptation result. Here, NEBA offers
    another powerful annotation: @Children. This annotation can be used on a Collection, Set or List-typed field
    (similar to the @Reference-annotation). Then, NEBA injects the children of either the current resource (if no other
    annotation is present), or of the resource defined by the @Reference or @Path of the field:</p>

{% highlight java %}@Children
private List<Resource> children;
{% endhighlight %}

<p>Of course, NEBA will also automatically adapt the children to the generic type of the list - for instance,
    you could write:</p>

{% highlight java %}
@Children
private List<Page> childPages;
{% endhighlight %}

<p>@Children can be combined with both @Reference and @Path to even fetch the children of a reference resource
    or a resource designated by a specific path, i.e. the following works as well:</p>

{% highlight java %}
@Path("/content/site")
@Children
private List<Page> countryPages;

@Reference
@Path("link")
@Children
private List<Page> linkChildren;

@Reference
@Children
private List<Page> link;
{% endhighlight %}

<p>
    Furthermore, you may specify a relative path to be resolved below every child using the property "resolveBelowEveryChild"
    instead of returning the direct children of the designated resource.
    For example, you could obtain all nodes called "jcr:content" underneath all children of the current resource, like so:
</p>

{% highlight java %}
@Children(resolveBelowEveryChild = "jcr:content")
private List<PageContent> childPageContents;
{% endhighlight %}

<h4 id="the_path_annotation">Using the @Path annotation to specify property names or resource paths</h4>

<p>Now, lets add another property to the model, jcr:lastModified.</p>

{% highlight java %}private Date lastModified;{% endhighlight %}

<p>This will not yet work - NEBA mapps the properties by <em>name</em>, in this case the name contains
    characters (&quot;jcr:&quot;) unsuitable for a field name.  In this case, use the @Path annotation to specify
    the property from which the field's value shall be obtained:</p>

{% highlight java %}
@Path("jcr:lastModified")
private Date lastModified;
{% endhighlight %}

<p>Now the property is mapped!  @Path has even more interesting features, for instance allowing absolute and
    relative paths.  Try this:</p>

{% highlight java %}
@Path("/content/geometrixx/en")
private Resource en;
{% endhighlight %}

<p id="path_placeholders">Furthermore, one can use placeholders in the @Path to dynamically provide path elements.
    A better version of above example is:</p>

{% highlight java %}
@Path("/content/geometrixx/${language}")
private Resource homepage;
{% endhighlight %}

<p>To resolve the ${language} placeholder, one simply provides a bean implementing the
    <a href="apidocs/neba-api/io/neba/api/configuration/class-use/PlaceholderVariableResolver.html">PlaceholderVariableResolver interface</a>.
    Such a bean instance will be asked to resolve the value for a placeholder key, i.e. &quot;language&quot;
    in the above example. A completely hardcoded example would be:</p>

{% highlight java %}
@Service
public class MyVariableResolver implements PlaceholderVariableResolver {
    public String resolve(String variableName) {
        if ("language".equals(variableName)) {
            return "en";
        }
        return null;
    }
}
{% endhighlight %}

<h4 id="the_this_annotation">The @This annotation</h4>

<p>Fields annotated with @This are injected with the current resource, or anything the resource is adaptable to. This annotation is thus not just useful for
access to the plain Resource, but has significant architectural value. Using @This, one may split up a model into multiple aspects and compose them dynamically, like so:</p>

{% highlight java %}
@ResourceModel(types = ...)
public class MyModel {
    @This
    // OtherModel models a different aspect of the same resource.
    private OtherModel resource;
}
{% endhighlight %}

<p>You can also use the @This annotation to obtain the Resource that is mapped onto the model:</p>

{% highlight java %}
@This
private Resource resource;
{% endhighlight %}

<h3>Models for crosscutting concerns</h3>
<p>A @ResourceModel is not restricted to sling:resourceType's - you can also map
    it to the JCR primary node type or any of the mixin types of a Node.  For example, let's assume that you
    have a requirement to implement a custom access protection of <em>arbitrary</em> content. In addition, a content manager may <em>configure</em>
    access restriction to <em>any</em> content (e.g. pages or a binary assets). In this case, we know neither the resource
    types nor the content paths to which the protection applies in advance.
    Here, using a mixin node type could help. A mixin can be assigned to any
    node at any time anywhere in the content hierarchy. It can define additional properties that can be set
    on the node, such as a set of properties defining how an access restriction is configured. Let us
    assume a protected content is assigned the mixin &quot;mix:AccessRestricted&quot;. You may then create
    a model for any access restricted content like so:</p>

{% highlight java %}
@ResourceModel(types = "mix:AccessRestricted")
public class AccessRestricted {
 ....
}
{% endhighlight %}

<p>Finally, you could adapt to this model (e.g., in a view or filter) to determine whether the
    corresponding resource has restricted access, and what the restrictions are.</p>

<p>Further reading: <a href="http://www.day.com/specs/jcr/2.0/3_Repository_Model.html">JCR repository
    spec</a>, <a href="http://dev.day.com/docs/en/crx/current/using_crx/nodetype_administration.html">administering
    node types</a>.</p>

<h3 id="lazy_loading">Lazy loading</h3>

<p>
    Reading data into an object graph - such as NEBA models referencing each other - bears the risk of loading
    more data than required for rendering. Especially when there is a significant amount of repository content, being able to load
    models <em>on demand</em> rather then up front is <em>crucial</em> for building high-performance implementations. To achieve this,
    NEBA enables lazy-loading model relationships.
</p>

<h4>Lazy loading collections of references</h4>

<p>
All collection-typed references are automatically provided as lazy-loading proxies, for example in case of
<a href="#api_Children">@Children</a> and <a href="#api_Reference">@Reference</a> collections:
</p>

{% highlight java %}
@ResourceModel(types = "...")
public class MyModel {
  @Children
  private List<Page> children; // Provided as a lazy-loading proxy
  @Reference
  private Collection<Page> pages; // Provided as a lazy-loading proxy as well
}
{% endhighlight %}

<p>
The contents of these collection are loaded as soon as a collection method - such as get, size, isEmpty, iterator - is called.
The lazy-loading behavior for collections is thus completely transparent.
</p>

<h4 id="the_optional_interface">Declaring lazy-loading relationships using the Optional&lt;T&gt; interface</h4>

<p>
1:1 relationships are not automatically lazy. In order to make them lazy-loading,
NEBA provides the <a href="apidocs/neba-api/io/neba/api/resourcemodels/Optional.html">Optional</a> interface:
</p>

{% highlight java %}
@ResourceModel(types = "...")
public class MyModel {
  @Reference
  private Optional<Page> page;
  @Path("/content/path")
  private Optional<Resource> otherResource;
}
{% endhighlight %}

With Optional, the relationships is loaded when one of Optional's methods for model retrieval is invoked.

<section class="info">
    <h4>Background: Why 1:1 relationships cannot be lazy by default</h4>
    <p>
        Let us assume there is a resource model that references resource "r":
    </p>

    {% highlight java %}
    @ResourceModel(types = "...")
    public class MyModel {
      @Reference
      private Resource r;

      public void doSomething() {
          if (r != null) {
             // work with r
          }
      }
    }
    {% endhighlight %}

    <p>
       Of course, any client working with "r" must know it exists. However, there is no natural "empty" representation for Resource -
       it is either null or not. Now, if r was provided as a lazy-loading proxy that proxy instance would never be null (since determining whether the resource represented by "r" exists
       would mean having to load it, which defeats the purpose of lazy-loading).
    </p>
    <p>
        A user of "r" would only find out that "r" does not exist when accessing a method of the "r" lazy-loading proxy - and receiving an
        unchecked exception in return, since the proxy cannot dispatch the method call as the loaded "r" is null.
    </p>
    <p>
        Consequently, lazy 1:1 relationships <em>must</em> be explicit to allow clients to determine whether the relationship exists.
        Collections, on the other hand, do have a natural representation of emptiness (isEmpty) and are thus automatically provided as lazy-loading proxies by NEBA.
    </p>
</section>

<p>
The Optional&lt;T&gt; interface is an extract of the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">JAVA 8 "Optional" interface</a>. NEBA
automatically provides an implementation that will load the reference upon request. Of course, you may also use the interface for collection-typed references:
</p>

{% highlight java %}
@ResourceModel(types = "...")
public class MyModel {
  @Children
  private Optional<Collection<Page>> children;
  @Reference
  private Optional<Collection<Page>> pages;
}
{% endhighlight %}

<p>
    In this case, NEBA will not provide the collection as a lazy-loading proxy, but simply load it when requested via
    the Optional interface implementation.
</p>

<h3 id="the_premapping_and_postmapping_annotations">Performing additional initializations</h3>

<p>It is often required to perform some additional initializations
    after all properties of a @ResourceModel are mapped. NEBA supports this use case with the @PostMapping and
    @PreMapping annotations.  Similar to @PostConstruct and @PreDestroy from standard Java, these annotations mark methods to be
    invoked after all properties of a resource model are mapped from its resource:</p>


{% highlight java %}@ResourceModel(types = "my/model/type")
public class MyModel {
   @This
   private Resource resource;
   @PostMapping
   public void initializeSomething() {
        // resource is initialized at this point.
        this.resource.adaptTo...
   }
}
{% endhighlight %}

<p>Likewise, @PreMapping allows for method execution before any properties of the resource are mapped.</p>

</section>