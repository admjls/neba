<section>
	<header><h2 id="extending">Extending NEBA</h2></header>

	<h3>Customizing the Spring MVC infrastructure</h3>

	<p>You may provide implementations of
		<a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html">Handler adapters</a>,
		<a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/HandlerExceptionResolver.html">Handler exception resolvers</a>
		and <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/HandlerMapping.html">Handler mappings</a>
		in your application context and / or use Spring's &lt;mvc&gt; XML namespace configuration without limitations.</p>

	<h3 id="post-processing-resourcemodels">Lifecycle callbacks</h3>

	<p>Additional functionality is usually provided by simply adjusting the
		spring context configuration to the project needs (i.e. configuring <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html">beans</a>
		and customizing the bean <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/html/beans.html#beans-factory-lifecycle">lifecycle</a>).
	</p>

	<p>However, there is an additional lifecycle phase of @ResourceModels in beans: after creation, dependency injection
		and initialization, a resource model is injected with the properties of the resource which is adapted to the model.
		For programmatic extensibility, the NEBA API contains the lifecycle callback interface <em>ResourceModelPostProcessor</em>.
		<br/>
		Providing an OSGi service with this interface allows customization and even overriding of a ResourceModel before and
		/ or after the resource properties are mapped on it.  The demo project's com.unic.cq.foundation.demo.i18n
		package and context.xml contain an example of how this lifecycle callback can be used to support an additional
		annotation on a resource model.</p>

	<h3 id="custom-annotation-based-field-mappers">First-class support for custom annotations</h3>

	<p>NEBA allows registering custom mappers for annotated fields. A custom mapper is an OSGi service implementing the
		<a href="apidocs/neba-api/io/neba/api/resourcemodels/AnnotatedFieldMapper.html">AnnotatedFieldMapper interface</a>.
		Implementations may map any non-transient annotated field, including
		fields directly or indirectly (meta-annotations) annotated with any of NEBA's standard annotations. Thus, AnnotatedFieldMappers are
		allowed to extend or override NEBA's standard annotation-based mapping behavior.</p>

	<h3>Extending the tag library</h3>

	<p>While NEBA's <em>DefineObjectsTag</em> and <em>RenderTag</em> are part of the NEBA API, writing a standalone tag
		library is the recommended approach to avoid tight coupling to implementation details of the
		NEBA tag library.</p>

	<h3 id="cache-extension">Caching and cache extension</h3>

	<p>NEBA's central and most performance critical feature is the adaptation of Resources to their corresponding resource models.
		There, resource and model resolution, content-to-object mapping and datatype conversion occurs.
		This core functionality features an extensible caching
		interface. Any OSGi service implementing the NEBA API interface <em>ResourceModelCache</em> will automatically be
		registered and used to cache the result of the resource to model adaptation.</p><p>NEBA ships with a safe and
	sensible default implementation of this interface contained in the core, the <em>request-scoped resource model
		cache.</em>
	This cache can be enabled or disabled via the Felix console (configuration tab). If you would like
	to provide your own caching implementation, consult the Javadoc of the <em>ResourceModelCache</em> <em>for further
		information.</em></p>
</section>